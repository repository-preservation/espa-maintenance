<!DOCTYPE html>
<!--[if lt IE 9]><script src="js/html5.js"></script><![endif]-->
<!--[if lt IE 7 ]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ESPA</title>
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- USGS Vis ID stylesheets -->
	<link rel="stylesheet" type="text/css" href="http://espa.cr.usgs.gov/ui/css/common.css" />
	<link rel="stylesheet" type="text/css" href="http://espa.cr.usgs.gov/ui/css/custom.css" />
	
	<!-- styles for the map and main sections of this page -->
    <link rel="stylesheet" type="text/css" href="http://espa.cr.usgs.gov/ui/css/map.css" />
    <link rel="stylesheet" type="text/css" href="http://espa.cr.usgs.gov/ui/css/main.css" />
	
    <link rel="stylesheet" type="text/css" href="http://espa.cr.usgs.gov/ui/formalize/css/formalize.css" />
    <link rel="stylesheet" type="text/css" href="http://espa.cr.usgs.gov/ui/openlayers/theme/default/style.css"/>
    
    <script src="openlayers/OpenLayers.js" type="text/javascript"></script>
    <script src="js/jquery-1.6.1.min.js" type="text/javascript"></script>
    <script src="js/date-alpha-1.min.js" type="text/javascript"></script>
    <script src="formalize/js/jquery.formalize.min.js" type="text/javascript"></script>
	<script src="js/jquery.tablescroll.js" type="text/javascript"></script>
    <script src="js/jquery.tmpl.min.js" type="text/javascript"></script>
    <script src="js/global.js" type="text/javascript"></script>
    <script src="js/progress.js" type="text/javascript"></script>
	<script src="js/overlay.js" type="text/javascript"></script>
    
</head> 
<body>
	<iframe id = "downloadIframe" style = "display:none"></iframe>
	<input type = "hidden" id = "CurrentSearchTerm" value = "" />
        <input type = "hidden" id = "FacetCount" value = "" />
	<div id = "header">
		<div id="usgsidentifier">
			<a href="http://www.usgs.gov/"><img src="http://eros.usgs.gov/ecms/images/header/header_graphic_usgsIdentifier_white.jpg"
				alt="USGS - science for a changing world"
				width="178" height="72" /></a>
		</div>
		<div id="identifierbg">
                    <!--			<img src="http://pubs.usgs.gov/of/1998/of98-136/doc/html/_usgs.gif" alt="" width="240" height="72" /> -->
                        <img src="http://eros.usgs.gov/ecms/images/header/logo_bg.png" alt="" width="240" height="72" />
		</div>
		<div id="rot">
			<img src="http://eros.usgs.gov/ecms/images/header/www-banner.jpg" alt="" width="1600" height="124" />
		</div>
		<div id="usgsccsabox">
			<div id="usgsccsa">
			  <br /><a href="http://www.usgs.gov/">USGS Home</a>
			  <br /><a href="http://www.usgs.gov/ask/">Contact USGS</a>
			  <br /><a href="http://search.usgs.gov/">Search USGS</a>
			  <br />
			</div>
		</div>
	<!-- Top Header Bar -->
		<div id="usgstitle">
                        <table style="width:100%">
                          <tr>
                          <td style="width:50%;"><p>ESPA GLS Visualization Interface</p></td>
			  <td style="width:50%;"><p style="float:right"><a href="http://landsat.usgs.gov/espa/files/espa_visui_userguide_20121012.docx">User Guide</a></p></td>
			  </tr>
			 </table>
                        
		</div>
	</div>

    <div id = "MousePosition" style = "float: right; color: #848484; font-weight: bold; font-size: 11px; height: 10px; text-align: right; padding: 5px 5px 0px 0px; position: relative; z-index: 50;"></div>
    
    <table id="content_wrap" style = "clear: both; position: relative; z-index: 10; top: -15px;">
        <td class="panel">
            <aside id="sceneInfo">
                <section class="searchOptions" >
                    <label for="sensor" style = "font-weight: bold; width: 65px; float: left; margin-top: 4px">Data Set</label>
                    <select id="dataset" style = "margin: 0px 0px 0px 0px; float: left">
                        <option value="gls-2010">GLS 2010</option>
                        <option value="gls-2005">GLS 2005</option>
                    </select>
                    <div id = "facetOptions" style = "width: 100%; clear: both; padding: 5px 0px 5px 0px"></div>
                </section>
				
				<section id="metaData" class="sceneList"></section>
				
				
                <section id="sceneResults" class="sceneList"></section>
                <section id="searchResults" class="sceneList"></section>
            </aside>
        </td>
        <td id="slider" class="slider"></td>
        <td id="map" style = "background-color: #000000;"></td>
    </table>
	
	<div id="footer">
		<div id="usgsfooter">
			<p id="usgsfooterbar">
				<a title="Accessibility Policy (Section 508)" href="http://www.usgs.gov/laws/accessibility.html">Accessibility</a>
				<a title="Freedom of Information Act" href="http://www.usgs.gov/foia/">FOIA</a>
				<a title="Privacy policies of the U.S. Geological Survey." href="http://www.usgs.gov/laws/privacy.html">Privacy</a>
				<a title="Policies and notices that govern information posted on USGS Web sites." href="http://www.usgs.gov/laws/policies_notices.html">Policies and Notices</a>
			</p>

			<p id="usgsfootertext">
				<a href="http://www.takepride.gov/">
					<img height="58" width="60" title="Take Pride in America Home Page" alt="Take Pride in America logo" src="http://eros.usgs.gov/ecms/images/footer/footer_graphic_takePride.jpg"/>
				</a>
				<a href="http://usa.gov/">
					<img height="26" width="90" title="USAGov: Government Made Easy" alt="USA.gov logo" src="http://eros.usgs.gov/ecms/images/footer/footer_graphic_usagov.jpg"/>
				</a>
				<a href="http://www.doi.gov/">U.S. Department of the Interior</a>
				<a href="http://www.usgs.gov/">U.S. Geological Survey</a>
				<br/>
				URL: <a href = ''><script type="text/javascript"> document.write(document.URL) </script></a>
				<br/>
				Page Contact Information:
				<a href="mailto:custserv@usgs.gov">custserv@usgs.gov</a>
				<br/>
				Page Last Modified:
				<script type="text/javascript">
				    <!--
				    lastmod = document.lastModified; 
				    lastmoddate = Date.parse(lastmod); 
					lastmodString = lastmoddate.toLocaleDateString() + ' at ' + lastmoddate.toLocaleTimeString();
				    if (lastmoddate == 0) {
				    } else {
					   document.write(lastmodString);
				    }
					// -->
			  </script>
			</p>
		</div>

	</div>
	
</body> 

<script type="text/javascript">

    //var MIN_SCALE = 5000000;  // minimum map scale to display the coverage layer
	//var MIN_SCALE = 9000000;  // minimum map scale to display the coverage layer
	var MIN_SCALE = 17500000;  // minimum map scale to display the coverage layer
    var map, scene, sceneID, sceneHighlight, rightClickMenu;
	//array to store the selected/highlighted scenes
	var selectedSceneArray = [];
    var mapElement, panelElement, sliderElement;
    var isBusy = false;
    var maxRows = 500;
    var searchResults, sceneResults, searchResultsTmpl, sceneResultsTmpl, searchStartTime, currentSearchResults;
    var progress;
	var overlay, overlayLayers;

	var downloadBaseUrl = "http://espa.cr.usgs.gov/collections/";
    var wmsServer = '/geoserver/wms';
	var wmsServerWithCaching = '/geoserver/gwc/service/wms';
    var wfsServer = '/geoserver/wfs';
    var restServer = '/geoserver/rest';
    var workspace = 'espa';

    jQuery(document).ready(function() {

        progress = new Progress({
            containerId: 'sceneInfo'
        });
		
		overlay = new Overlay({
            containerId: 'sceneInfo'
        });

        // pink tile avoidance
        OpenLayers.IMAGE_RELOAD_ATTEMPTS = 5;
        // make OL compute scale according to WMS spec
        OpenLayers.DOTS_PER_INCH = 25.4 / 0.28;

        // set up the bounds for the map
        var bounds = new OpenLayers.Bounds(
            -180, -90,
            180, 90
        );
        var sceneBounds = new OpenLayers.Bounds(
            -136, 52,
            -56, 20
        )

        var options = {
            controls: [
                new OpenLayers.Control.PanZoomBar({
                    position: new OpenLayers.Pixel(2, 15),
                    zoomWorldIcon: true
                }),
                //new OpenLayers.Control.Navigation(),
				new OpenLayers.Control.Navigation(),
                //new OpenLayers.Control.MousePosition(),
				new OpenLayers.Control.MousePosition({
					//emptyString: 'Mouse is not over map'
					div: document.getElementById('MousePosition'),
					formatOutput: formatMousePosData
				}),
                new OpenLayers.Control.LayerSwitcher(),
                new OpenLayers.Control.OverviewMap({
                    size: new OpenLayers.Size(300, 150)
                })
                //new OpenLayers.Control.SelectFeature(),
                //new OpenLayers.Control.ScaleLine()
            ],
            maxExtent: bounds,
            maxResolution: 1.40625,
            units: 'degrees',
            projection: new OpenLayers.Projection("EPSG:4326"),
            displayProjection: new OpenLayers.Projection("EPSG:4326")
        };
        map = new OpenLayers.Map('map', options);
		
		function formatMousePosData(lonLat) {
			var lat = Math.round(lonLat.lat * 100000) / 100000;
			var lon = Math.round(lonLat.lon * 100000) / 100000;
	
		   return lat + ", " + lon;
		}
		
		
		// Get control of the right-click event:
		document.getElementById('map').oncontextmenu = function(e){
			e = e?e:window.event;
			if (e.preventDefault) e.preventDefault(); // For non-IE browsers.
			else return false; // For IE browsers.
		};

		// A control class for capturing click events...
		OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {                
		defaultHandlerOptions: {
			'single': true,
			'double': true,
			'pixelTolerance': 0,
			'stopSingle': false,
			'stopDouble': false
			}, 
			handleRightClicks:true,
			initialize: function(options) {
				this.handlerOptions = OpenLayers.Util.extend({}, this.defaultHandlerOptions);
				OpenLayers.Control.prototype.initialize.apply(this, arguments); 
				this.handler = new OpenLayers.Handler.Click(this, this.eventMethods, this.handlerOptions);
			},	CLASS_NAME: "OpenLayers.Control.Click"
		});


		// Add an instance of the Click control that listens to various click events:
		var oClick = new OpenLayers.Control.Click({eventMethods:{
			'rightclick': function(e) {
				
				rightClickLonLat = map.getLonLatFromViewPortPx(e.xy);
				drawRightClickMenu(rightClickLonLat);
			},
			'click': function(e) {
				//removeRightClickMenu();
			},
			'dblclick': function(e) {
				removeRightClickMenu();
			},
			'dblrightclick': function(e) {
				removeRightClickMenu();
			}
			
		}});
		map.addControl(oClick);
		oClick.activate();
		
		// draw the right click menu
		function drawRightClickMenu(rightClickLonLat) {
			removeRightClickMenu();
		
			var rightClickHTML = "<div class=\"rightClickMenu\">";
			
			var rightClickMenuHasItems = false;
			
			if (map.getScale() <= MIN_SCALE && scene) {
				rightClickMenuHasItems = true;
				
				rightClickHTML += 	 "<div class=\"item\" onclick = \"viewSelectedSceneMetaData('" + sceneID + "'); closeRightClickMenu();\">" +
										"View Scene Meta Data" +
									 "</div>" +
									 "<div class=\"item\" onclick = \"downloadScene('" + sceneID + "'); closeRightClickMenu();\">" +
										"Download Scene" +
									 "</div>";
			}
			
			rightClickHTML += "</div>";
			
			if (rightClickMenuHasItems) {
				rightClickMenu = new OpenLayers.Popup("rightClickMenu",
				rightClickLonLat,
				//new OpenLayers.Size(175,23),
				new OpenLayers.Size(175,69),
				rightClickHTML,
				false);
				rightClickMenu.backgroundColor = "transparent";
				map.addPopup(rightClickMenu);
				rightClickMenu.show();
			}
		}
		
		

        // set up image layers
        var bluemarble = new OpenLayers.Layer.WMS(
            'Blue Marble', 
            //wmsServer,
			wmsServerWithCaching,
            {
                layers: workspace + ':bluemarble_pyramid',
                format: 'image/jpeg',
                tilesOrigin : map.maxExtent.left + ',' + map.maxExtent.bottom
            },
            {
                buffer: 0,
                displayOutsideMaxExtent: true,
                wrapDateLine: true,
                isBaseLayer: true,
                singleTile: false
            } 
        );
		
		var noBaseLayer = new OpenLayers.Layer("None", {isBaseLayer: true});

        // set up wrs2 layer
        var wrs2 = new OpenLayers.Layer.WMS(
            'WRS-2',
            wmsServer,
            {
                layers: workspace + ':wrs2_descending',
                transparent: true,
                tiled: false
            },
            {
                opacity: 0.1,
                singleTile: true,
                visibility: false,
                displayInLayerSwitcher: true
            } 
        );

        // set up countries layer
        var countries = new OpenLayers.Layer.WMS(
            'Political Boundaries',
            wmsServer,
			//wmsServerWithCaching,
            {
                layers: workspace + ':countries',
                transparent: true,
                tiled: false,
                styles: 'espa_boundaries'
            },
            {
                opacity: 0.5,
                singleTile: true,
                visibility: true
            } 
        );

		/*
        // set up states layer
        var states = new OpenLayers.Layer.WMS(
            'State Boundaries',
            wmsServer,
			//wmsServerWithCaching,
            {
                layers: workspace + ':statesp020',
                transparent: true,
                tiled: false,
                styles: 'espa_boundaries'
            },
            {
                opacity: 0.5,
                singleTile: true,
                visibility: true
            } 
        ); 
		*/ 
		
		var noaaStatesProvincesLayer = new OpenLayers.Layer.WMS(
			"State/Province",
			wmsServer,
			{
				srs: "EPSG:3857",
				layers: 'noaa_states_provinces_layer_group',
				format: 'image/png',
				transparent: true
			},
			{
				isBaseLayer: false,
				//singleTile: true,
				opacity: 1.0,
				visibility: true
			}
		);
		
		var noaaLandRegionLayer = new OpenLayers.Layer.WMS(
			"Land Region",
			wmsServerWithCaching,
			{
				srs: "EPSG:3857",
				layers: 'noaa_region_layer_group',
				format: 'image/png',
				transparent: true
			},
			{
				isBaseLayer: false,
				opacity: 1.0,
				visibility: false
			}
		);
		
		var noaaCitiesLayer = new OpenLayers.Layer.WMS(
			"World Cities",
			wmsServerWithCaching,
			{
				srs: "EPSG:3857",
				layers: 'noaa_cities_layer_group',
				format: 'image/png',
				transparent: true
			},
			{
				isBaseLayer: false,
				opacity: 1.0,
				visibility: false
			}
		);
		
		var noaaOceanLayer = new OpenLayers.Layer.WMS(
			"Ocean",
			wmsServerWithCaching,
			{
				srs: "EPSG:3857",
				layers: 'noaa_ocean_layer_group',
				format: 'image/png',
				transparent: true
			},
			{
				isBaseLayer: false,
				opacity: 1.0,
				visibility: false
			}
		);
		
		var noaaRiversLayer = new OpenLayers.Layer.WMS(
			"River",
			wmsServerWithCaching,
			{
				srs: "EPSG:3857",
				layers: 'noaa_rivers_layer_group',
				format: 'image/png',
				transparent: true
			},
			{
				isBaseLayer: false,
				opacity: 1.0,
				visibility: false
			}
		);
		
		/*
		var gls_2005_sampleLayer = new OpenLayers.Layer.WMS(
            'GLS 2005 Sample Coverage', 
            wmsServerWithCaching,
            {
                layers: 'gls-2005_sample_layer_group',
                transparent: true,
                format: 'image/png',
                tiled: true,
                tilesOrigin : map.maxExtent.left + ',' + map.maxExtent.bottom
            },
            {
                buffer: 0,
                displayOutsideMaxExtent: true,
                wrapDateLine: true,
                isBaseLayer: false,
                minScale: MIN_SCALE,
                displayInLayerSwitcher: true,
                visibility: true
            } 
        );
		*/
		
		/*
		var gls_2005_singleLayer = new OpenLayers.Layer.WMS(
			"LT50250332006258EDC00",
			wmsServerWithCaching,
			{
				srs: "EPSG:4326",
				layers: workspace + ":LT50250332006258EDC00",
				format: 'image/png',
				transparent: true
			},
			{
				isBaseLayer: false,
				opacity: 1.0,
				visibility: false
			}
		);
		
		var gls_2010_pyramid = new OpenLayers.Layer.WMS(
            'GLS 2010', 
			wmsServerWithCaching,
            {
                layers: workspace + ':gls-2010_pyramid',
				srs: "EPSG:4326",
                format: 'image/png',
				transparent: true
            },
            {
                isBaseLayer: false,
				opacity: 1.0,
                visibility: false,
				displayInLayerSwitcher: true,
            } 
        );
		*/
		
        // add layers to the map and zoom to the base level
        var layers = [bluemarble, noBaseLayer, countries, noaaStatesProvincesLayer, noaaLandRegionLayer, noaaCitiesLayer, noaaOceanLayer, noaaRiversLayer, wrs2];
		overlayLayers = [countries, noaaStatesProvincesLayer, noaaLandRegionLayer, noaaCitiesLayer, noaaOceanLayer, noaaRiversLayer];
		
        map.addLayers(layers);
		
		var raise = layers.length;
		
        map.zoomToExtent(sceneBounds);
        //map.zoomToMaxExtent();

		//NOTE: The format of the event passed back from the get feature info call to GeoServer relies on a specific format
		//that is determined by a couple of templates that GS uses. They are located at <geoserver_data_dir>/templates
        var info = new OpenLayers.Control.WMSGetFeatureInfo({
            url: wmsServer, 
            title: 'Identify features by clicking',
            layers: [wrs2],
            queryVisible: false,
			format : new OpenLayers.Format.GeoJSON(),
            //infoFormat: '',
            eventListeners: {
                getfeatureinfo: function(event) {
                    // only do this if we are zoomed in to the scale where the coverage layer is displayed
                    if (map.getScale() <= MIN_SCALE) {
                        // remove the previously displayed scene layer
                        removeAllSelectedScenes();
						//removeSceneLayer();
                        // determine the path/row for the scene that was clicked
                        var features = null, feature = null;
                        if (event && event.text) {
                            features = jQuery.parseJSON(event.text);
                        }
                        if (features && features.length > 0) {
                            // take the first feature to use for the path/row
                            feature = features[0];
                            
                            // get the list of scenes for the current path/row
                            var scenes = getScenesForPathRow(feature.PATH, feature.ROW);
                            scenes.path = feature.PATH;
                            scenes.row = feature.ROW;
                            
                            // write out the scene results
							/*
                            var html = sceneResultsTmpl.tmpl(scenes, {
                                formatDate: function(dateString) {
                                    // use date.js because javascript date object not consistent with older IE browsers
                                    var date = Date.parseExact(dateString, 
                                        'yyyy-MM-dd\THH:mm:ssZ');
                                    return (date) ? date.toString('MM/dd/yyyy') : '';
                                }
                            });
                            jQuery('#sceneResults').html(html);
							*/
                            
                            // display the first scene in the list that exists as a layer
                            if (scenes && scenes.docs && scenes.docs.length > 0) {
                                var count = scenes.docs.length;
                                for(var i = 0; i < count; i++) {
                                    var scene = scenes.docs[i];
                                    // show and highlight the new scene layer
                                    if (!layerExists(scene.sceneID)) {
                                        //TESTING: write to console
										//console.log('Scene ' + scene.sceneID + ' does not exist');
                                    } else {

										addSelectedScene(scene.sceneID, true);
										
										/*
										addSceneLayer(scene.sceneID);
										
										sceneID = scene.sceneID;
                                        drawSceneHighlight(
                                            scene.lowerLeftCornerLatLong.split(',')[1] + ',' + scene.lowerLeftCornerLatLong.split(',')[0],
                                            scene.lowerRightCornerLatLong.split(',')[1] + ',' + scene.lowerRightCornerLatLong.split(',')[0],
                                            scene.upperLeftCornerLatLong.split(',')[1] + ',' + scene.upperLeftCornerLatLong.split(',')[0],
                                            scene.upperRightCornerLatLong.split(',')[1] + ',' + scene.upperRightCornerLatLong.split(',')[0]
                                        );
										*/
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });
        map.addControl(info);
        info.activate();
       
        // handler to update search results when panning and/or zooming
        jQuery('#sceneInfo select').attr('disabled', 'disabled');
        map.events.register('moveend', map, function(level) {
			//TESTING:
			//alert(map.getScale());
            if (map.getScale() <= MIN_SCALE) {
				var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Searching. Please wait...</div>";
				$('#facetOptions').html(searchFacetHTML);
				generateSearchOptions();
                jQuery('#sceneInfo select').removeAttr('disabled');
            } else {
                //removeAllSelectedScenes();
				//removeSceneLayer();
                clearSearchResults();
                clearSceneResults();
                jQuery('#sceneInfo select').attr('disabled', 'disabled');
				$('#facetOptions').html('');
            }
        });
        
        // handler to execute the scene search whenever a drop-down entry changes
        jQuery('#sceneInfo select').live('change', function() {
			var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Searching. Please wait...</div>";
				$('#facetOptions').html(searchFacetHTML);
			clearSceneResults();
			deselectAllScenes();
            //removeAllSelectedScenes();
			//removeSceneLayer();
			generateSearchOptions();
        })
                

        // handler for the slider click
        mapElement = jQuery('#map');
        panelElement = jQuery('#content_wrap .panel');
        sliderElement = jQuery('#slider');
        sliderElement.live('click', function() {
            if (panelElement.is(':visible')) {
                sliderElement.addClass('collapsed');
                mapElement.addClass('expanded');
                panelElement.hide();
            } else {
                sliderElement.removeClass('collapsed');
                mapElement.removeClass('expanded');
                panelElement.show();
            }
            // let openlayers know to change the map size
            map.updateSize();
        });
		
		//handler for the panel click
		panelElement.live('click', function() {
			//remove the right click menu in the map
            removeRightClickMenu();
        });
		        
        // handler for expanding/contracting search results
        jQuery('#sceneInfo .sceneList .title .expand_contract').live('click', function() {
            var header = jQuery(this).closest('.group');
            if (header.hasClass('expanded')) {
                jQuery('.detail', header).hide();
                jQuery('footer', header).hide();
                header.removeClass('expanded');
            } else {
                jQuery('.detail', header).show();
                jQuery('footer', header).show();
                header.addClass('expanded');
            }
        });
        
        jQuery('#searchResults .id a').live('click', function() {
            clearSceneResults();
        });
		
        // handler for the screen resize
        jQuery('#sceneInfo').height(jQuery(window).height());
        window.onresize = function() {
            jQuery('#sceneInfo').height(jQuery(window).height());
        }
        
        // create the search and scene results templates
        searchResultsTmpl = jQuery('#searchResultsTmpl');    
        sceneResultsTmpl = jQuery('#sceneResultsTmpl');  
		
		//handler for the select checkbox
		$('#sceneInfo .sceneList .highlight input:checkbox').live('click', function(e) {
			// will stop event from "bubbling"
			e.stopPropagation()
			
			var cbEl = jQuery(this);
			var sceneID = cbEl.val();
			
			var idEl = jQuery('#' + sceneID + '_id');
			
			if (cbEl.is(':checked'))
			{
				var origSearchFacetHTML = $('#facetOptions').html();
				var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Selecting scene. Please wait...</div>";
				$('#facetOptions').html(searchFacetHTML);
			
				cbEl.attr('title', 'Deselect ' + sceneID);
				idEl.attr('title', 'Deselect ' + sceneID);
				addSelectedScene(sceneID, false);
				
				$('#facetOptions').html(origSearchFacetHTML);
			}
			else
			{
				var origSearchFacetHTML = $('#facetOptions').html();
				var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Deselecting scene. Please wait...</div>";
				$('#facetOptions').html(searchFacetHTML);
				
				cbEl.attr('title', 'Select ' + sceneID);
				idEl.attr('title', 'Select ' + sceneID + ' with highlight box');
				removeSelectedScene(sceneID);
				
				$('#facetOptions').html(origSearchFacetHTML);
			}
			
			var ssStatus = getScenesSelectionStatus();
			if ("All Selected" == ssStatus)
			{
				setDeselectAllButton()
			}
			else if("None Selected" == ssStatus)
			{
				setSelectAllButton();
			}
			else
			{
				setSelectAllButton();
			}
		});
		
		//handler for the select checkbox
		$('#sceneInfo .sceneList .id').live('click', function(e) {
			// will stop event from "bubbling"
			e.stopPropagation()
			
			var idEl = jQuery(this);
			var sceneID = idEl.html();
			
			var cbEl = jQuery('#' + sceneID + '_checkbox');

			if (cbEl.is(':checked'))
			{
				var origSearchFacetHTML = $('#facetOptions').html();
				var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Selecting scene. Please wait...</div>";
				$('#facetOptions').html(searchFacetHTML);
				
				cbEl.prop('checked', false);
				cbEl.attr('title', 'Select ' + sceneID);
				idEl.attr('title', 'Select ' + sceneID + ' with highlight box');
				removeSelectedScene(sceneID);	
				
				$('#facetOptions').html(origSearchFacetHTML);
			}
			else
			{
				var origSearchFacetHTML = $('#facetOptions').html();
				var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Deselecting scene. Please wait...</div>";
				$('#facetOptions').html(searchFacetHTML);
				
				cbEl.prop('checked', true);
				cbEl.attr('title', 'Deselect ' + sceneID);
				idEl.attr('title', 'Deselect ' + sceneID);
				addSelectedScene(sceneID, true);
				
				$('#facetOptions').html(origSearchFacetHTML);
			}
			
			var ssStatus = getScenesSelectionStatus();
			if ("All Selected" == ssStatus)
			{
				setDeselectAllButton()
			}
			else if("None Selected" == ssStatus)
			{
				setSelectAllButton();
			}
			else
			{
				setSelectAllButton();
			}
		});
		 
    });
	
	
	
	function alertObject(obj, returnOutput)
	{
		var alertString = "";
		for (i in obj)
		{
			alertString += i + ": " + obj[i] + "\n";
		}
		
		if (returnOutput == true)
		{
			return alertString;
		}
		else
		{
			alert(alertString);
		}
	}
	
	
	
	function viewSelectedSceneMetaData(sceneID)
	{
		// build the url for the query
		var url = '/solr/select?indent=on&version=2.2';
		//url += '&fl=sceneID,sensor,browseURL,path,row,acquisitionDate,lowerLeftCornerLatLong,lowerRightCornerLatLong,upperLeftCornerLatLong,upperRightCornerLatLong';
		url += '&fl=*';
		url += '&q=sceneid:' + sceneID;
		url += '&wt=json';
		
		jQuery.ajax({
			type: 'get',
			url: url,
			cache: false,
			async: false,
			dataType: 'json',
			success: function(result) {
				if (result && result.response && result.response) {
	
					var scene = result.response.docs[0];
						
					var dataObj;
					var dataArray = new Array();
					
					dataObj = new Object();
					var acqDate = Date.parseExact(scene.acquisitionDate, 'yyyy-MM-dd\THH:mm:ssZ');
					acqDate = acqDate.toString('MM/dd/yyyy HH:mm:ssZ');
					dataObj.label = "Acquisition Date";
					dataObj.data = acqDate;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Sensor";
					dataObj.data = scene.sensor;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Path";
					dataObj.data = scene.path;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Row";
					dataObj.data = scene.row;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Upper Left Corner Lat/Lon";
					dataObj.data = scene.upperLeftCornerLatLong;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Upper Right Corner Lat/Lon";
					dataObj.data = scene.upperRightCornerLatLong;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Lower Left Corner Lat/Lon";
					dataObj.data = scene.lowerLeftCornerLatLong;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Lower Right Corner Lat/Lon";
					dataObj.data = scene.lowerRightCornerLatLong;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Center Lat/Lon";
					dataObj.data = scene.sceneCenterLatLong;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Sun Elevation";
					dataObj.data = scene.sunElevation;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Sun Azimuth";
					dataObj.data = scene.sunAzimuth;
					dataArray.push(dataObj);
					
					dataObj = new Object();
					dataObj.label = "Ground Station";
					dataObj.data = scene.groundStation;
					dataArray.push(dataObj);
					
					//format the collection value for human readablility
					var collectionValue = "";
					if (scene.collection == "gls-2010")
					{
						collectionValue = "GLS 2010";
					}
					else if (scene.collection == "gls-2005")
					{
						collectionValue = "GLS 2005";
					}
					
					dataObj = new Object();
					dataObj.label = "Collection";
					dataObj.data = collectionValue;
					dataArray.push(dataObj);
					
					var metaHTML = "<div class=\"metaData\" id = 'metaData'>" +
									   "<div class = 'title floatleft full_width bold center'>" +
									       "Meta Data for Scene " + sceneID +
								       "</div>";
									   
					for (i in dataArray)
					{
						metaHTML += "<div class = 'row full_width floatleft'>" +
									   "<div class = 'label floatleft bold'>" + dataArray[i].label + "</div>" +
									   "<div class = 'data floatleft'>" + dataArray[i].data + "</div>" +
								    "</div>";
					}
						metaHTML += "<div class = 'row full_width floatleft center' style = 'padding: 5px 0px 0px 0px'>" +
									   "<input type = \"button\" value = \"Close\" onclick = \"closeOverlay();\" />" +
								    "</div>";			   
					metaHTML +=    "</div>";
								   
					overlay.show(metaHTML);
					
					/*
					//set the overlay click handler to close the overlay when not clicking on metaData element
					$('#overlay').click(function(event){
						if (event.target.id != "metaData")
						{
							overlay.hide();
						}
					 });
					 */
				}
			},
			error: function(xmlRequest, status, error) {
				if (error) {
					alert(error);
				}
			}
		});
	}
	
	function closeRightClickMenu() {
		removeRightClickMenu();
	}
	
	function closeOverlay() {
		overlay.hide();
	}
	
	function downloadScene(sceneID)
	{
		// build the url for the query
        var url = '/solr/select?indent=on&version=2.2';
        url += '&fl=*';
        url += '&q=sceneid:' + sceneID;
        url += '&wt=json';
		
		//TESTING:
		//alert('downloadScene solr query:\n' + url);
        
		// make call to the server to get the data
        jQuery.ajax({
            type: 'get',
            url: url,
            cache: false,
            dataType: 'json',
            success: successDownloadScene,
            error: errorDownloadScene
        });
	}
	
    function successDownloadScene(result, status) {
        if (result) {
            // write out the scene count
            var numRows = (result.response.docs) ? result.response.docs.length : 0;
            var numFound = result.response.numFound;

            // write out the search results
            sceneFoundResult = (numRows > 0) ? result.response : null;
			
			if (sceneFoundResult != null)
			{
				for (i in sceneFoundResult.docs)
				{
					var sceneInfo = sceneFoundResult.docs[i];
				
					var sceneSensor = sceneInfo.sensor;
					if ("ETM+" == sceneSensor)
					{
						sceneSensor = "etm";
					}
					else if ("TM" == sceneSensor)
					{
						sceneSensor = "tm";
					}
					
					var sceneAcqDateYear = Date.parseExact(sceneInfo.acquisitionDate, 'yyyy-MM-dd\THH:mm:ssZ');
					sceneAcqDateYear = sceneAcqDateYear.toString('yyyy');
					
					// construct the url to open
					var sceneDownloadUrl = downloadBaseUrl + sceneInfo.collection + "/sr/" + sceneSensor + "/" + sceneInfo.path + "/" + sceneInfo.row + "/" + sceneAcqDateYear;
					
					//TESTING:
					//alert(sceneDownloadUrl);
					
					newWin = window.open(sceneDownloadUrl);
				}
				
				
			}     
        } else {
            alert('Error on Scene Download');
        }
        isBusy = false;
    }
	
    function errorDownloadScene(xmlRequest, status, error) {
        searchResults = null;
        if (error) {
            alert(error);
        }
        isBusy = false;
    }
	
	function reorderOverlayLayerIndexes(layer)
	{
		var outputString = "";
		var output = false;
		var startIndex = map.getLayerIndex(layer) - overlayLayers.length;
		map.setLayerIndex(layer, startIndex);
		outputString += "new layer layerIndex: " + map.getLayerIndex(layer) + "\n";
		startIndex++;
		
		var curIndex = startIndex;
		for (i in overlayLayers)
		{
			var overlayLayer = overlayLayers[i];
			map.setLayerIndex(overlayLayer, curIndex);
			outputString += "overlayLayer layerIndex: " + map.getLayerIndex(overlayLayer) + "\n";
			curIndex++;
		}
		
		if (output)
		{
			alert(outputString);
		}
	}
	
	/*
	*	selectedScene is a function that creates an object containing data for a selected scene
	*
	*	Parameters:
	*	sceneID (string) - the id of the scene
	*	layer (object) - an OpenLayers map layer for the scene
	*/
	function SelectedScene(sceneID, layer, highlightLayer, highlightLayerDisplayed)
	{
		this.sceneID = sceneID;
		this.layer = layer;
		this.highlightLayer = highlightLayer;
		this.highlightLayerDisplayed = highlightLayerDisplayed;
	}
	
	function addSelectedScene(sceneID, displayHighlighLayer)
	{
		if (!sceneID) 
		{
            alert('addSelectedScene - no sceneID specified.');
            return;
        }
		
		if (!layerExists(sceneID)) 
		{
			//mark the id red if no layer exists
			jQuery('#' + sceneID + "_id").css('color', 'red');
			return;
		} 
		
		var sceneCheckboxElement = jQuery('#' + sceneID + "_checkbox");
		
		//create a wms layer for the scene
		var sceneLayer = new OpenLayers.Layer.WMS(
			sceneID, 
			//wmsServer,
			wmsServerWithCaching,
			{
				layers: workspace + ':' + sceneID,
				transparent: true,
				format: 'image/jpeg',
				tiled: true
			},
			{
				buffer: 0,
				displayOutsideMaxExtent: true,
				wrapDateLine: true,
				isBaseLayer: false,
				displayInLayerSwitcher: false
			} 
		);
		//add the scene layer
		map.addLayer(sceneLayer);
		//reorder the layer indexes
		reorderOverlayLayerIndexes(sceneLayer);
		
		//create/add the Highlight Layer
		var sceneHLLayer = drawSceneHighlight(sceneCheckboxElement.data('bounds-ll'),sceneCheckboxElement.data('bounds-lr'),sceneCheckboxElement.data('bounds-ul'),sceneCheckboxElement.data('bounds-ur'));
		var highlightLayerDisplayed = false;
		if (displayHighlighLayer == true)
		{
			//remove all selected scene's highlight layers, leaving the scene displayed
			removeAllSelectedSceneHighlightLayers()
		
			map.addLayer(sceneHLLayer);
			//reorder the layer indexes
			reorderOverlayLayerIndexes(sceneHLLayer);
			highlightLayerDisplayed = true;
		}
		
		//add the scene to the array
		var ssObj = new SelectedScene(sceneID, sceneLayer, sceneHLLayer, highlightLayerDisplayed);
		selectedSceneArray.push(ssObj);
	}
	
	function removeAllSelectedSceneHighlightLayers()
	{
		for(i in selectedSceneArray)
		{
			var sObj = selectedSceneArray[i];
			
			if (sObj.highlightLayerDisplayed == true)
			{
				map.removeLayer(sObj.highlightLayer);
				
				selectedSceneArray[i].highlightLayerDisplayed = false;
			}
		}
	}
	
	function removeSelectedScene(sceneID)
	{
		//TESTING
		//alert('removing selected scene: ' + sceneID);
		
		if (!sceneID) 
		{
            alert('removeSelectedScene - no sceneID specified.');
            return;
        }
	
		for(i in selectedSceneArray)
		{
			var sObj = selectedSceneArray[i];
			
			if (sObj.sceneID == sceneID)
			{
				//remove the scene and highlight layers
				map.removeLayer(sObj.layer);
				if (sObj.highlightLayerDisplayed == true)
				{
					map.removeLayer(sObj.highlightLayer);
				}

				//remove the object
				selectedSceneArray.splice(i, 1);
			}
		}
	}
	
	function removeAllSelectedScenes()
	{
		for(i in selectedSceneArray)
		{
			var sObj = selectedSceneArray[i];
			//remove the scene and highlight layers
			map.removeLayer(sObj.layer);
			if (sObj.highlightLayerDisplayed == true)
			{
				map.removeLayer(sObj.highlightLayer);
			}
			//remove the object
			selectedSceneArray.splice(i, 1);
		}
	}
	
	function isSelectedScene(sceneID)
	{
		for(i in selectedSceneArray)
		{
			var sObj = selectedSceneArray[i];
			
			if (sObj.sceneID == sceneID)
			{
				return true;
			}
		}
		return false;
	}
	
	
	/*
    function addSceneLayer(sceneId) {
        if (!sceneId) {
            alert('You need to specify a scene id.');
            return;
        }
		
		//mark the menu item scene id
		jQuery('#' + sceneId).css('color', '#00539d');
		jQuery('#' + sceneId).css('text-decoration', 'underline');
		
		//place the scene
		sceneID = sceneId;
		
        // add the layer
        scene = new OpenLayers.Layer.WMS(
            sceneId, 
            wmsServer,
            {
                layers: workspace + ':' + sceneId,
                transparent: true,
                format: 'image/jpeg',
                tiled: true
            },
            {
                buffer: 0,
                displayOutsideMaxExtent: true,
                wrapDateLine: true,
                isBaseLayer: false,
                displayInLayerSwitcher: false
            } 
        );

        map.addLayer(scene);
        
    }

    function removeSceneLayer() {
        if (scene) {
            map.removeLayer(scene);
            scene = null;
			
			//mark the menu item scene id
			jQuery('#' + sceneID).css('color', '#000000');
			jQuery('#' + sceneID).css('text-decoration', 'none');
        }
        removeSceneHighlight();
    }
	
	function removeSceneHighlight() {
        if (sceneHighlight) {
            map.removeLayer(sceneHighlight);
            sceneHighlight = null;
        }
    }
	*/

    function drawSceneHighlight(ll, lr, ul, ur) {
        // offsets to correct the positioning of the vector layer
        var X_OFFSET = 0.04, Y_OFFSET = 0.03;
        
        // create the vector layer
        var sceneHighlight = new OpenLayers.Layer.Vector('layer highlight', {
            renderers: OpenLayers.Layer.Vector.prototype.renderers,
            displayInLayerSwitcher: false,
			rendererOptions: { zIndexing: true }
        });
        
        // create the array of points to draw
        var pointList = [];
        var start = new OpenLayers.Geometry.Point(parseFloat(ll.split(',')[0]) + X_OFFSET, parseFloat(ll.split(',')[1]) + Y_OFFSET);
        pointList.push(start);
        pointList.push(new OpenLayers.Geometry.Point(parseFloat(ul.split(',')[0]) + X_OFFSET, parseFloat(ul.split(',')[1]) + Y_OFFSET));
        pointList.push(new OpenLayers.Geometry.Point(parseFloat(ur.split(',')[0]) + X_OFFSET, parseFloat(ur.split(',')[1]) + Y_OFFSET));
        pointList.push(new OpenLayers.Geometry.Point(parseFloat(lr.split(',')[0]) + X_OFFSET, parseFloat(lr.split(',')[1]) + Y_OFFSET));
        pointList.push(start);
        
        // create the line feature to draw on the vector layer
        var lineFeature = new OpenLayers.Feature.Vector(
            new OpenLayers.Geometry.LineString(pointList),
            null,
            {
                strokeColor: "#f3fa69",
                strokeWidth: 2,
                strokeDashstyle: "solid",
                pointerEvents: "visiblePainted"
            }
        );
            
        sceneHighlight.addFeatures([lineFeature]);
		
		return sceneHighlight;
    }

    
    
    function layerExists(sceneId) {
        var url = restServer + '/layers/' + sceneId + '.json';
		
        var response = jQuery.ajax({
            type: 'get',
            url: url,
            cache: false,
            async: false,
            dataType: 'json'
        });
        return response.status == 200;
    }
	
    function getScenesForPathRow(path, row) {
        var scenes = null;
        
        // prevent accidental resubmit
        if (isBusy) {
            return;
        }
        isBusy = true;
        
        // build the url for the query
        var url = '/solr/select?indent=on&version=2.2';
        url += '&fl=*';
        url += '&q=path:' + path;
        url += ' AND row:' + row;
		url += ((jQuery('#dataset').val() != 'ALL') ? ' AND collection:' + jQuery('#dataset').val() : '');
        //url += ((jQuery('#dataset').val() != 'ALL') ? ' AND sensor:' + jQuery('#dataset').val() : '');
        url += '&sort=acquisitionDate desc,path asc,row asc';
        url += '&rows=' + maxRows;
        url += '&wt=json';
		
		//TESTING:
		//alert("getScenesForPathRow:\n\n" + url);
        
        jQuery.ajax({
            type: 'get',
            url: url,
            cache: false,
            async: false,
            dataType: 'json',
            success: function(result) {
                if (result && result.response && result.response) {
                    scenes = result.response;
                }
            },
            error: function(xmlRequest, status, error) {
                if (error) {
                    alert(error);
                }
            }
        });
        isBusy = false;
        return scenes;
    }
	
	function search(paramString) {
	
		// prevent accidental resubmit
        if (isBusy) {
            return;
        }
        isBusy = true;
        
        // get the current map extent
        if (!map) {
            alert('no map');
            return;
        }
        var extent = map.getExtent();
        if (!extent) {
            alert('no extent');
            return;
        }
		
		//TESTING
		//alert("long distance: " + (extent.right - extent.left) + ", lat distance: " + (extent.top - extent.bottom) );

		var paramArray = paramString.split("&");
			
		setInputValue("CurrentSearchTerm",paramString);
          
        // build the url for the query
        //var url = '/solr/select?indent=on&version=2.2';
        var url = '/solr/select?q=*:*&indent=on';

        //url += '&fl=*';
	//url += '&q=*:*';	

		//query for all scenes that "touch" the viewing area

                //alert("bottom:" + extent.bottom + " left:" + extent.left + " top:" + extent.top + " right:" + extent.right);

		url += '&fq=latitude_longitude:[' + extent.bottom + ',' + extent.left + ' TO ' + extent.top + ',' + extent.right + '] AND ';

                /*
                url += '&q=upperLeftCornerLatLong:[' + extent.bottom + ',' + extent.left + ' TO ' + extent.top + ',' + extent.right + '] OR ';
		url += 'upperRightCornerLatLong:[' + extent.bottom + ',' + extent.left + ' TO ' + extent.top + ',' + extent.right + '] OR ';
		url += 'lowerLeftCornerLatLong:[' + extent.bottom + ',' + extent.left + ' TO ' + extent.top + ',' + extent.right + '] OR ';
		url += 'lowerRightCornerLatLong:[' + extent.bottom + ',' + extent.left + ' TO ' + extent.top + ',' + extent.right + '] AND ';
		*/
		//OLD: query for all scenes completely within the viewing area
		/*
		url += '&q=upperLeftCornerLatLong:[' + extent.bottom + ',' + extent.left;
        url += ' TO ' + extent.top + ',' + extent.right + '] AND ';
		url += 'lowerRightCornerLatLong:[' + extent.bottom + ',' + extent.left;
        url += ' TO ' + extent.top + ',' + extent.right + '] AND ';
		*/
		
		//OLD: query using the sceneCenterLatLong
        //url += '&q=sceneCenterLatLong:[' + extent.bottom + ',' + extent.left;
       // url += ' TO ' + extent.top + ',' + extent.right + '] AND ';
		
		var searchTerms = getInputValue('CurrentSearchTerm');
		
		var searchTermArray = searchTerms.split('&');
		
		for (var j = 0; j < searchTermArray.length; j++)
		{
			var parts = searchTermArray[j].split('=');
			var field = parts[0];
			var val = parts[1];
			
			url += field + ':' + val;
			if (j < searchTermArray.length - 1)
			{
				url += ' AND ';
			}
		}
        //url += '&sort=path asc,row asc,acquisitionDate asc';
		url += '&sort=row asc,path desc,acquisitionDate desc';
        url += '&rows=' + maxRows;
        url += '&wt=json';
		
		//TESTING:
		//alert('search solr query:\n' + url);
        
        searchStartTime = new Date();
        
        // make call to the server to get the data
        jQuery.ajax({
            type: 'get',
            url: url,
            cache: false,
            dataType: 'json',
            success: successFetchScenes,
            error: errorFetchScenes
        });
    }
    
    function successFetchScenes(result, status) {
        searchResults = null;
        if (result) {
			//TESTING:
			//alert("in successFetchScenes");
			//alertObject(result.response);
		
            // write out the elapsed time
            jQuery('#sceneQueryTime').html('Elapsed time: ' + (new Date() - searchStartTime) + ' ms');
            
            // write out the scene count
            var numRows = (result.response.docs) ? result.response.docs.length : 0;
            var numFound = result.response.numFound;
            jQuery('#sceneCount').html('Scenes found: ' + numFound + ' (' + numRows + ' displayed)');
            
            // write out the search results
            searchResults = (numRows > 0) ? result.response : null;
			
			//write out the displayed scenes
			var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Displayed Scenes: " + numFound + "</div>";
			$('#facetOptions').html(searchFacetHTML);
			
			//TESTING:
			/*
			var oString = "searchResults docs\n\n";
			for(i in searchResults.docs)
			{
				oString += "\n" + alertObject(searchResults.docs[i], true);
			}
			alert(oString);
			*/
			
			var alreadySelected = new Array();
			if (searchResults != null)
			{
				currentSearchResults = new Array();
				for (i in searchResults.docs)
				{
					var as = isSelectedScene(searchResults.docs[i].sceneid);
					//if the scene is already in selected
					if (as)
					{
						alreadySelected.push(searchResults.docs[i].sceneid);
					}
				
					currentSearchResults.push(searchResults.docs[i]);
				}
			}
			
			//remove any selected scenes not in the viewing area
			for(var i = 0; i < selectedSceneArray.length; i++)
			{
				var removeThisItem = true;
				for (var j = 0; j < alreadySelected.length; j++)
				{
					//alert('checking ' + selectedSceneArray[i].sceneID + ' against alreadySelected ' + alreadySelected[j]);
					if (selectedSceneArray[i].sceneID == alreadySelected[j])
					{
						removeThisItem = false;
					}
				}
				if (removeThisItem)
				{
					//alert('remove previously selected scene: ' + selectedSceneArray[i].sceneID);
					removeSelectedScene(selectedSceneArray[i].sceneID);
				}
			}
			
            var html = searchResultsTmpl.tmpl(searchResults, {
                isHeader: function(index, value) {
                    return (index == 0 || (index < numRows &&
                        value.acquisitionDate.substring(0, 4) != searchResults.docs[index - 1].acquisitionDate.substring(0, 4)));
                },
                formatDate: function(dateString) {
                    // use date.js because javascript date object not consistent with older IE browsers
                    var date = Date.parseExact(dateString, 
                        'yyyy-MM-dd\THH:mm:ssZ');
                    return (date) ? date.toString('MM/dd/yy') : '';
                },
				formatDownloadUrl: function(valObj) {
                    // use date.js because javascript date object not consistent with older IE browsers
				
					var sceneSensor = valObj.sensor;
					if ("ETM+" == sceneSensor)
					{
						sceneSensor = "etm";
					}
					else if ("TM" == sceneSensor)
					{
						sceneSensor = "tm";
					}
					
					var sceneAcqDateYear = Date.parseExact(valObj.acquisitionDate, 'yyyy-MM-dd\THH:mm:ssZ');
					sceneAcqDateYear = sceneAcqDateYear.toString('yyyy');
					
					// construct the url to open
					var sceneDownloadUrl = downloadBaseUrl + valObj.collection + "/sr/" + sceneSensor + "/" + valObj.path + "/" + valObj.row + "/" + sceneAcqDateYear + "/" + valObj.sceneid + "-sr.tar.gz";
					
					//TESTING:
					//alert(sceneDownloadUrl);
					
                    return sceneDownloadUrl;
                },
				isSelectedScene: function(sceneID) {
                   for(i in selectedSceneArray)
					{
						var sObj = selectedSceneArray[i];
						
						if (sObj.sceneID == sceneID)
						{
							return "checked";
						}
					}
					return "";
                },
				layerExistsColor: function(sceneID) {
                   var url = restServer + '/layers/' + sceneID + '.json';
		
					var response = jQuery.ajax({
						type: 'get',
						url: url,
						cache: false,
						async: false,
						dataType: 'json'
					});
					
					var colorStyle;
					if (response.status == 200)
					{
						colorStyle = "color: red";
					}
					else
					{
						colorStyle = "color: black";
					}
					return colorStyle;
                }
            });
			
            jQuery('#searchResults').html(html);
            
            if (result.response.numFound > maxRows) {
                // TODO - do something here
				//TESTING: write to console
                //console.log('max number of rows exceeded');
            }
            
       
            
        } else {
            alert('ERROR - data not returned');
        }
        isBusy = false;
    }
	
	function formatDate(dateString) {
		// use date.js because javascript date object not consistent with older IE browsers
		var date = Date.parseExact(dateString, 
			'yyyy-MM-dd\THH:mm:ssZ');
		return (date) ? date.toString('MM/dd') : '';
    }
    
    function errorFetchScenes(xmlRequest, status, error) {
        searchResults = null;
        if (error) {
            alert(error);
        }
        isBusy = false;
    }
    
    function clearSearchResults() {
        jQuery('#sceneQueryTime').html('');
        jQuery('#sceneCount').html('');
        jQuery('#searchResults').html('');
    }    
    
    function clearSceneResults() {
		jQuery('#sceneResults').html('');
    }
    
    function flipCoords(coords) {
        if (!coords) {
            return;
        }
        var arr = coords.split(',');
        return arr[1] + ',' + arr[0];
    }
	
	function clearInputValue(id)
	{
		$('#' + id).attr('value', '');
	}
	
	function setInputValue(id,val)
	{
		$('#' +id).attr('value', val);
	}
	
	function getInputValue(id)
	{
		return $('#' +id).attr('value');
	}

    function getFacetCount(facetQueryStringArray)
	{
		var url = '/solr/select?indent=on&version=2.2';
		url += '&q=*:*&facet=true';
		
		var extent = map.getExtent();
		var extentFacet = "";
        if (extent) 
		{
            extentFacet += ' AND sceneCenterLatLong:[' + extent.bottom + ',' + extent.left;
			extentFacet += ' TO ' + extent.top + ',' + extent.right + ']';
		}
		
		for (var i = 0; i <facetQueryStringArray.length; i ++)
		{
			url += '&facet.query=' + facetQueryStringArray[i] + extentFacet;
		}
		url += '&wt=json';
		
		//TESTING:
		//alert("facet solr query:\n" + url);

		var ajaxRequest = jQuery.ajax({
			type: 'get',
			url: url,
			cache: false,
			dataType: 'json',
			//need to make synchronous call, as this data needs to be set before functions that call this function can have their code executed
			async: false,
			success: parseFacetCount,
			error: errorFacetCount
		});
	}

	function parseFacetCount(result)
	{
		facetCount = "";

		for (i in result.facet_counts.facet_queries)
		{
			//alert(i + ", " + result.facet_counts.facet_queries[i]);
			facetCount += result.facet_counts.facet_queries[i] + ",";
		}

		if (facetCount.length > 0)
		{
			facetCount = facetCount.substring(0, facetCount.length - 1);
		}

		setInputValue('FacetCount', facetCount);
		
		//TESTING:
		//alert("Facet Count Input value:\n" + getInputValue('FacetCount'));
	}

	function errorFacetCount(xmlRequest, status, error)
	{
		alert("Error on faceting");
		setInputValue('FacetCount', '');
	}

    function generateSearchOptions()
	{
		
	
		var dataset = jQuery('#dataset option:selected').val();
		
		var facetTermArray = new Array();
		//TESTING: using sensor for facet query, the facet will most likely use the "collection" field of the solr index
		//var term = "sensor:" + dataset;
		var term = "collection:" + dataset;
		facetTermArray.push(term);

		getFacetCount(facetTermArray);
		var facetCountString = getInputValue('FacetCount');
		
		var searchString = "";
		for (var i = 0; i < facetTermArray.length; i++)
		{
			searchString += facetTermArray[i].replace(":", "=");;
			if (i < facetTermArray.length -1)
			{
				searchString += "&";
			}
		}
		search(searchString);
	}
	
	function getScenesSelectionStatus()
	{
		var numOfResults = currentSearchResults.length;
		var numOfScenesSelected = 0;
		for(var i = 0; i < numOfResults; i++)
		{
			if (isSelectedScene(currentSearchResults[i].sceneid))
			{
				numOfScenesSelected++;
			}
		}
		
		var returnVal;
		if (numOfScenesSelected == numOfResults)
		{
			returnVal = "All Selected";
		}
		else if (numOfScenesSelected == 0)
		{
			returnVal = "None Selected";
		}
		else
		{
			returnVal = "Some Selected";
		}
		
		return returnVal;
	}
	
	function selectAllScenes()
	{
		//TESTING
		//var startTimestamp = new Date().getTime() / 1000;
	
	
		var origSearchFacetHTML = $('#facetOptions').html();
		var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Selecting all scenes. Please wait...</div>";
		$('#facetOptions').html(searchFacetHTML);
				
		for(var i = 0; i < currentSearchResults.length; i++)
		{
			if (!isSelectedScene(currentSearchResults[i].sceneid))
			{
				addSelectedScene(currentSearchResults[i].sceneid, false);
			}
			document.getElementById(currentSearchResults[i].sceneid + '_checkbox').checked = true;
		}
		
		setDeselectAllButton();
		
		$('#facetOptions').html(origSearchFacetHTML);
		
		
		//TESTING
		//var endTimestamp = new Date().getTime() / 1000;
		//var diff = endTimestamp - startTimestamp;
		//alert('selecting all scenes took ' + diff + ' seconds');
		
	}
	
	function deselectAllScenes()
	{
		var origSearchFacetHTML = $('#facetOptions').html();
		var searchFacetHTML = "<div style = \"padding-bottom: 8px; width: 100%\">Deselecting all scenes. Please wait...</div>";
		$('#facetOptions').html(searchFacetHTML);
		
		for(var i = 0; i < currentSearchResults.length; i++)
		{
			if (isSelectedScene(currentSearchResults[i].sceneid))
			{
				removeSelectedScene(currentSearchResults[i].sceneid);
			}
			document.getElementById(currentSearchResults[i].sceneid + '_checkbox').checked = false;
		}
		
		//also remove all selected scenes
		//TESTING
		//alert('selected scene outside of current search results: ' + selectedSceneArray.length);
		for(i in selectedSceneArray)
		{
			var sObj = selectedSceneArray[i];
			//alert('remove: ' + sObj.sceneID);
			removeSelectedScene(sObj.sceneID);
		}
		
		setSelectAllButton();
		
		$('#facetOptions').html(origSearchFacetHTML);
	}
	
	function setSelectAllButton()
	{
		var button = document.getElementById('SelectDeselectAllButton');
		if (button !== null)
		{
			button.value = "Select All";
			button.onclick = function() { selectAllScenes() };
		}
	}
	
	function setDeselectAllButton()
	{
		var button = document.getElementById('SelectDeselectAllButton');
		if (button !== null)
		{
			button.value = "Deselect All";
			button.onclick = function() { deselectAllScenes() };
		}
	}

	// hide/remove the right click menu
	function removeRightClickMenu(){
			if (rightClickMenu != null) {
					rightClickMenu.hide();
					map.removePopup(rightClickMenu);
			}
	}
		
</script>

<!-- search results template -->
<script id="searchResultsTmpl" type="text/x-jquery-tmpl">
    
    {{if docs}}
        {{each docs}}
		   {{if $index == 0}}
                <div class="group expanded" id = "Returned_SearchResults">
					
                    <h3 class="title">
                        <a class = "expand_contract">Search Results</a>
						{{if docs.length <= 50}}
						<input id = "SelectDeselectAllButton" type = "button" value = "Select All" style = "float: right" onclick = "selectAllScenes()"/>
						{{/if}}
                    </h3>
					
                    <div class="detail">
                        <table>
                         <thead>
                            <tr>
								<th class="highlight">&nbsp;</th>
                                <th class="download">&nbsp;</th>
                                <th class="id">Scene ID</th>
                                <th class="path">Path, Row</th>
                                <th class="date">Acq. Date</th>
								<th>&nbsp;</th>
                            </tr>
                        </thead>
                        <tbody>
                         
           {{/if}}
		    
           <tr>
		   		<th class="highlight"><input type = "checkbox" title = "Select ${$value.sceneid}" id = "${$value.sceneid}_checkbox" value = "${$value.sceneid}" data-bounds-ll="${flipCoords($value.lowerLeftCornerLatLong)}" data-bounds-lr="${flipCoords($value.lowerRightCornerLatLong)}" data-bounds-ul="${flipCoords($value.upperLeftCornerLatLong)}" data-bounds-ur="${flipCoords($value.upperRightCornerLatLong)}" ${$item.isSelectedScene($value.sceneid)}/></th>
                <td class="download">
					<a href = "${$item.formatDownloadUrl($value)}" title = "Download this scene">
						<img src="img/download_button.png" alt="Download Button" width="17" height="15" style = "margin-top: 2px"/>
					</a>
				</td>
                <td class="id" id = "${$value.sceneid}_id" title = "Select ${$value.sceneid} with highlight box">${$value.sceneid}</td>
                <td class="path">${$value.path},${$value.row}</td>
                <td class="date">${$item.formatDate($value.acquisitionDate)}</td>
				<td><a style = "display:block; margin-top: -1px;" href = "javascript:void(0);" onclick="viewSelectedSceneMetaData('${$value.sceneid}');"><img src="img/helpinfo.png" alt="View Scene Meta Data" width="16" height="16"/></a></td>
            </tr>
        {{/each}}
		</tbody></table></div><footer></footer></div>
    {{else}}
        <div class="group expanded">
            <h3 class="title">
                <a>Search Results</a>
            </h3>
            <div class="detail">
                <table> 
                    <tbody>
                        <tr>
                            <td>No data found for the search criteria</td>
                        </tr>
                    </tbody>            
                </table>
            </div>
            <footer></footer>
        </div>
    {{/if}}
     
</script>

</html>
